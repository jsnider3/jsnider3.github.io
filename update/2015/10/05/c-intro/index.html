<!DOCTYPE html>
<html>

  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>Barriers to Learning C</title>
    <meta name="viewport" content="width=device-width initial-scale=1">
    <meta name="description" content="An attempt at a blog by someone who thinks Haskell is cool.">
    <link rel="canonical" href="http://www.joshuasnider.com/update/2015/10/05/c-intro/">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/main.css">

</head>

  
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-61510914-1', 'auto');
  ga('send', 'pageview');

</script>



    <body>

    <header class="site-header">

  <div class="wrap">

    <a class="site-title" href="/">(\x -> "Blog")</a>

    <nav class="site-nav">
      <a href="#" class="menu-icon">
        <svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
           viewBox="0 0 18 15" enable-background="new 0 0 18 15" xml:space="preserve">
          <path fill="#505050" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0
            h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
          <path fill="#505050" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484
            h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
          <path fill="#505050" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0
            c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
        </svg>
      </a>
      <div class="trigger">
        <a class="page-link" href="/"> Home </a>
        
          
          
        
          
          
            <a class="page-link" href="/about/">About</a>
          
        
          
          
        
          
          
        
      </div>
    </nav>

  </div>

</header>


    <div class="page-content">
      <div class="wrap">
      <div class="post">

  <header class="post-header">
    <h1>Barriers to Learning C</h1>
    <p class="meta">Oct 5, 2015</p>
  </header>

  <article class="post-content">
  <p>Updated: 2015-10-06</p>

<p>I recently had the good fortune of talking to a graduate of a local web
developer bootcamp<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup> who was interested in learning C. The
syntax of C should be familiar to anyone who knows Java, but the real
barriers are semantic. In my opinion, there are two main barriers for
people to learning C, the difference between a pointer to a value and a
value and the difference between memory on the stack and memory on the heap.
I’m going to address a few errors in those areas, before suggesting a
project that would be useful for testing yourself.</p>

<p>The basic idea<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup> of a pointer is that it’s a location in memory,
where a value is stored and that we can give others access to our local
values by passing around pointers to them. This implies that every value in
the system must be assigned a location in memory where it is stored.
We can also choose to pass around a copy of our value instead for
simplicity and to prevent others from editing our values without our
permission. contrast, a value is passed around entirely by people making local copies
of it which aren’t shared and can be updated without affecting far off
corners of the program.</p>

<p>A quick note on syntax before I give an example. A value can be converted
to a pointer with the ampersand, as in <code>&amp;value</code>. A pointer can be converted
to a value with a *, as in <code>*ptr</code> and you can assign to the underlying
value of a pointer with <code>*ptr = value</code>.</p>

<p>Consider this file containing a main and two slightly different methods</p>

<div class="highlight"><pre><code class="language-c" data-lang="c"><span class="cp">#include &lt;stdio.h&gt;</span>
<span class="kt">int</span> <span class="nf">add_five</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">source</span><span class="p">)</span> <span class="p">{</span>
	<span class="o">*</span><span class="n">source</span> <span class="o">+=</span> <span class="mi">5</span><span class="p">;</span>
	<span class="k">return</span> <span class="o">*</span><span class="n">source</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">plus_five</span><span class="p">(</span><span class="kt">int</span> <span class="n">num</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">num</span> <span class="o">+=</span> <span class="mi">5</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">num</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">val</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">plus_five</span><span class="p">(</span><span class="n">val</span><span class="p">);</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">&quot;val is now %d. result is %d.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
 	<span class="n">result</span> <span class="o">=</span> <span class="n">add_five</span><span class="p">(</span><span class="o">&amp;</span><span class="n">val</span><span class="p">);</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">&quot;val is now %d. result is %d.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span> 
<span class="p">}</span></code></pre></div>

<p>The result of compiling and executing this on my computer<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup> is:</p>

<div class="highlight"><pre><code class="language-text" data-lang="text">val is now 5. result is 10.
val is now 10. result is 10.</code></pre></div>

<p>Why? <code>plus_five</code> works by taking a value adding five to it and returning the
result. <code>add_five</code> works by taking a pointer to a number, adding five to
what’s stored at that location, and returning what’s stored there.</p>

<p>The other barrier is the difference between memory on the stack and memory
on the heap. As a rule of thumb, malloc<sup id="fnref:4"><a href="#fn:4" rel="footnote">4</a></sup> is on the heap and
everything else, from plain ints to char[]’s, is on the stack. The
practical difference is that memory on the heap has to be cleaned up by
calling free when you’re done with it and memory on the stack is cleaned
up whenever the method or block that needed it is over, regardless of
whether you’re actually done with it.
Consider this other file containing a main and two test methods. It
allocates two arrays, one on the stack and one on the heap, fills them both
in with the numbers 0 through 9, and then prints them out.</p>

<div class="highlight"><pre><code class="language-c" data-lang="c"><span class="cp">#include &lt;stdio.h&gt;</span>
<span class="cp">#include &lt;stdlib.h&gt;</span>
<span class="kt">int</span><span class="o">*</span> <span class="nf">heap_alloc</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="o">*</span><span class="mi">10</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span><span class="o">*</span> <span class="nf">stack_alloc</span><span class="p">()</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">stuff</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="n">stuff</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="o">*</span><span class="n">stack</span> <span class="o">=</span> <span class="n">stack_alloc</span><span class="p">();</span>
	<span class="kt">int</span> <span class="o">*</span><span class="n">heap</span> <span class="o">=</span> <span class="n">heap_alloc</span><span class="p">();</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">x</span><span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="n">x</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">stack</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
		<span class="n">heap</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="n">x</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">&quot;stack: %d heap: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">stack</span><span class="p">[</span><span class="n">x</span><span class="p">],</span> <span class="n">heap</span><span class="p">[</span><span class="n">x</span><span class="p">]);</span>
	<span class="p">}</span>
	<span class="n">free</span><span class="p">(</span><span class="n">heap</span><span class="p">);</span>
<span class="p">}</span></code></pre></div>

<p>A naive perspective would expect them to have the same output. However,
running it on my machine<sup id="fnref:5"><a href="#fn:5" rel="footnote">5</a></sup> with <code>gcc test.c -std=c99 &amp;&amp; a.out</code>
gives me the output:</p>

<div class="highlight"><pre><code class="language-text" data-lang="text">stack: 0 heap: 0
stack: 0 heap: 1
stack: 0 heap: 2
stack: 0 heap: 3
stack: 4196252 heap: 4
stack: 0 heap: 5
stack: -954667288 heap: 6
stack: 50 heap: 7
stack: 1 heap: 8
stack: 0 heap: 9</code></pre></div>

<p>So, why are they different? The first method, heap_alloc, is completely
valid and it’s sometimes useful to have a small method that takes a few
arguments, mallocs a struct, and initializes the struct based on the
supplied values.<sup id="fnref:6"><a href="#fn:6" rel="footnote">6</a></sup> The second method, however, should never be
used and gcc will give you a  “function returns address of local variable”
warning when you compile it. Here’s what happens under the hood: 40-80
bytes of memory are allocated for the stuff array on the stack, you take
the address of the beginning of that array, the method ends, and the stack
space is automatically reclaimed by the system. The system is then free to
hand it off to the next person who wants it and since they’re free to edit
that memory in whatever way they want they do.</p>

<p>Consider walking through a linked list. In Java, you would just take a
java.util.LinkedList and walk it in a for-each loop like
<code>for (String elem : myList)</code>. In Python, you’d probably have to make your
own linked list class and implement an <code>__iter__</code> function to walk through
it. In C however, we need to make a “struct” which is just a block of
values and then create a separate function to walk it. Something like:</p>

<div class="highlight"><pre><code class="language-c" data-lang="c"><span class="k">struct</span> <span class="n">list_node</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">num</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">list_node</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">list_print</span><span class="p">(</span><span class="k">struct</span> <span class="n">list_node</span> <span class="o">*</span><span class="n">start</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">start</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">start</span><span class="o">-&gt;</span><span class="n">num</span><span class="p">);</span>
		<span class="n">start</span> <span class="o">=</span> <span class="n">start</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span></code></pre></div>

<p>A little project I would suggest is to implement a simulation of
first-fit<sup id="fnref:7"><a href="#fn:7" rel="footnote">7</a></sup> memory allocation. Consider the following API</p>

<ul>
  <li>
    <p><code>void* my_malloc(int size)</code>: Walk through the list of free spaces, when you
find a spot that can fit a block of the requested size allocate the block
and adjust the list accordingly, return NULL and leave the state unchanged
if you can’t.</p>
  </li>
  <li>
    <p><code>int my_free(void *block)</code>: Given a pointer to a block, check if it’s
something’s you’ve allocated before. If it’s one you’ve allocated, move
it back to the list of free blocks and return zero. If it’s one you
haven’t allocated, do nothing and return one.</p>
  </li>
  <li>
    <p><code>void print_state()</code>: Print the current status of the free blocks in
whatever way allows you to check your work.</p>
  </li>
</ul>

<p>Think of what test cases you would want, work out those test cases by hand,
write code to solve the problem (note that I suggested this after working
them out by hand, that was intentional), and debug it with gdb until your
code’s output matches what you did by hand. At this point you should know
what the different thought processes needed for C programming are. If
you’ve gotten this far, there’s one question I’d like you to consider.
Suppose someone wants to allocate a block that’s bigger than any free space,
but smaller than the sum amount of free space, what prevents us from moving
the allocated blocks into one giant block so that all the free blocks are
in one giant block and allocating from there?<sup id="fnref:8"><a href="#fn:8" rel="footnote">8</a></sup></p>

<hr />

<p><strong>Footnotes:</strong></p>

<div class="footnotes">
  <ol>
  <li id="fn:1"> General Assembly and John Master to be specific.<a href="#fnref:1" rev="footnote">↩</a></li>
  <li id="fn:2"> Extremely dumbed down, of course.<a href="#fnref:2" rev="footnote">↩</a></li>
  <li id="fn:3"> And in any compliant implementation of C.<a href="#fnref:3" rev="footnote">↩</a></li>
  <li id="fn:4"> sbrk is another way to get memory from the heap and is what malloc uses internally. You shouldn’t use it unless you have really good reasons to.<a href="#fnref:4" rev="footnote">↩</a></li>
  <li id="fn:5"> I encourage you in the strongest possible terms to run these programs on your own computer instead of just taking my word. Unlike the previous example, this behavior can vary between machines.<a href="#fnref:5" rev="footnote">↩</a></li>
  <li id="fn:6"> This is basically a poor man’s constructor.<a href="#fnref:6" rev="footnote">↩</a></li>
  <li id="fn:7"> First-fit is a largely arbitrary choice. Best-fit and worst-fit are also good choices.<a href="#fnref:7" rev="footnote">↩</a></li>
  <li id="fn:8"> This is done by compacting garbage collectors in higher level languages. Why can’t we do it here?<a href="#fnref:8" rev="footnote">↩</a></li>
  </ol>
</div>

  <footer><small>Click <a href="https://github.com/jsnider3/jsnider3.github.io/issues/new">here</a>
  to suggest a topic through GitHub. If you don't have a GitHub, feel free to 
  <a href='mailto:josh@joshuasnider.com'>email me.</small></footer>

  </article>

  
    <div align="left">
    <a class="prev" href="/update/2015/09/14/suggest-posts/">&laquo; Suggest a Post</a>
    </div>
  
  
    <div align="right">
    <a class="next" href="/update/2015/11/10/take-notes/">You're not Taking Enough Notes &raquo;</a>
    </div>
  

</div>

      </div>
    </div>

    
<div id="disqus_thread" class="wrap"></div>
<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES * * */
    var disqus_shortname = 'jsnider3';
    
    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>


    <footer class="site-footer">

  <div class="wrap">

    <h2 class="footer-heading">(\x -> "Blog")</h2>

    <div class="footer-col-1 column">
      <ul>
        <li>(\x -> "Blog")</li>
        <li><a href="mailto:josh@joshuasnider.com">josh@joshuasnider.com</a></li>
      </ul>
    </div>

    <div class="footer-col-2 column">
      <ul>
        <li>
          <a href="https://github.com/jsnider3">
            <span class="icon github">
              <svg version="1.1" class="github-icon-svg" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
                 viewBox="0 0 16 16" enable-background="new 0 0 16 16" xml:space="preserve">
                <path fill-rule="evenodd" clip-rule="evenodd" fill="#C2C2C2" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761
                c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32
                c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472
                c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037
                C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65
                c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261
                c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082
                c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129
                c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/>
              </svg>
            </span>
            <span class="username">jsnider3</span>
          </a>
        </li>
        <li>
          <script src="//platform.linkedin.com/in.js" type="text/javascript"></script>
          <script type="IN/MemberProfile" data-id="https://www.linkedin.com/in/jsnider3" data-format="hover" data-related="false"></script>
        </li>
      </ul>
    </div>

    <div class="footer-col-3 column">
      <p class="text">An attempt at a blog by someone who thinks Haskell is cool.</p>
    </div>

  </div>

</footer>


    </body>
</html>
